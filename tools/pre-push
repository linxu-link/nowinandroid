#!/bin/bash
#
# 使用方法：将此文件复制到您仓库的 .git/hooks 目录中。将其命名为
# "pre-push" 并设置可执行权限。
#
# 当要推送的任何提交的日志消息以 "WIP"（进行中）或 "stash" 开头，
# 且远程引用以 "refs/for/" 开头时，此钩子会中止 git push。这可以防止
# 不完整/不需要的提交被推送到 Gerrit 实例。
#
# 推送到 Gerrit 时，此钩子还会运行类似于 Gerrit 预提交的 Gradle 构建，
# 以帮助在本地捕获错误并减少 CL 上的来回修改。
#
# 其余注释复制自 .git/hooks/pre-push.sample。
#
# 一个示例钩子脚本，用于验证即将推送的内容。在 "git push" 检查远程状态后调用，
# 但在任何内容被推送之前。如果此脚本以非零状态退出，则不会推送任何内容。
#
# 使用以下参数调用此钩子：
#
# $1 -- 要推送到的远程名称
# $2 -- 要推送到的 URL
#
# 如果不使用命名的远程推送，这些参数将相等。
#
# 有关正在推送的提交的信息以以下形式提供给标准输入：
#
#   <本地引用> <本地 sha1> <远程引用> <远程 sha1>

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
  # 处理删除
  if [[ "$local_sha" = "$z40" ]]; then
    echo "$local_ref, $remote_ref"
    :
  # 如果不匹配 refs/for/ 则继续
  elif [[ ! "$remote_ref" =~ ^refs/for/.+ ]]; then
    echo "$local_ref, $remote_ref"
    :
  else
    echo "$local_ref, $local_sha, $remote_ref, $remote_sha"
    if [[ "$remote_sha" = "$z40" ]]; then
      # 新分支，检查所有提交
      branchname="${remote_ref#refs/for/}"

      if [[ "$branchname" =~ % ]]; then
        # Gerrit 允许通过使用 "%<选项>=<字符串>[,<选项>=<字符串>...]"
        # 附加到远程来添加各种推送选项。将这些剥离掉。
        # TODO: '%' 是分支名称中的有效字符，因此可能会损坏
        # 分支名称。我们应该找到一种方法来绕过这个问题。
        echo "注意：剥离以 '%' 开头的 Gerrit 推送选项"
        branchname=${branchname%%\%*}
      fi

      if git check-ref-format --allow-onelevel "$branchname"; then
        range="${remote}/${branchname}..$local_sha"
      fi

      if [[ -z "$range" ]]; then
        range="$local_sha"
      fi
    else
      # 更新到现有分支，检查新提交
      range="$remote_sha..$local_sha"
    fi

    echo "正在检查 $range"

    # 检查 WIP/stash 提交
    commit=`git rev-list -n 1 -i --grep '^WIP' --grep '^stash' "$range"`
    if [[ -n "$commit" ]]; then
      echo >&2 "在 $local_ref 中发现 WIP/stash 提交，不推送 ($commit)"
      exit 1
    fi

    # 至少有一个引用将推送到 Gerrit，因此我们应该运行额外检查
    run_checks=true
  fi
done

if [[ -n "$run_checks" ]]; then
  # pre-push 通常在仓库根目录执行，但为了安全起见...
  cd "$(git rev-parse --show-toplevel)"
  ./gradlew check
  exit $?
fi

exit 0
